# 变量定义</br>
> 变量定义等号前后不能加空格，例如："A=123"</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# 数组定义引用</br>
> A=( test1 test2 test3 )</br>
> 引用: echo ${A[0/1/2/...]}</br>
> 显示所有参数 echo ${A[@]}将显示所有参数=> test1 test2 test3</br>
> 显示参数个数 echo ${#A[@]} => 3</br>
> 替换某个数组元素，例如退还第二个test2数组为test5: echo ${A[@]/test2/test5}</br>
> 如何删除某个数组元素，例如删除test3 => unset A[2]</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# 计算任意精度数</br>
> a=$(echo "scale=n;$num1/$num2"|bc) //scale=n;n是多少就保留多少位小数</br>
> j=`bc <<< "$num1*$num2-$num3"`</br>
> b=$(echo "$num1 $num2" | awk '{printf("%n.mf\n",$1/$2)}')</br>
> awk 'BEGIN{printf"%.2f\n",'$num1'/'$num2'}'</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# 计算整数</br>
> c=`expr $num1 + $num2` //使用乘号\* 的时候必须使用转义符号</br>
> let "d=$num1+$num2"</br>
> ((e=$num1+$num2))</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# bc 使用</br>
> ibase指定输入的数字进制</br>
> obase指定输出的数字进制</br>
> scale设定小数位</br>
> echo "obase=10;ibase=2;$num1+$num2" | bc</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# 系统常用参数</br>
> $# 是传给脚本的参数个数</br>
> $n 是第n个参数</br>
> $0 是脚本本身的名字</br>
> $1 是传递给该shell脚本的第一个参数</br>
> $2 是传递给该shell脚本的第二个参数</br>
> $@ 是传给脚本的所有参数的列表</br>
> $\* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个</br>
> $$ 是脚本运行的当前进程ID号</br>
> $? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# 基本命令用法</br>
> 输出重定向">"妙用："命令 >& 目标文件"  "命令 &> 目标文件"</br>
> 输入重定向"<"妙用："命令 < 目标文件"  "命令 < 目标文件"</br>
> bash +* ***xx.sh 和 ./xx.sh 子shell执行方式</br>
> .(空格)xx.sh 和 source xx.sh 当前shell的执行方式*********</br>
> login shell   ==> su - username</br>
> nologin shell ==> su username</br>
> 系统级shell配置 ==> /etc/profile /etc/bashrc</br>
> 用户级shell配置 ==> 登录时加载：~/.bashrc ~/.bash_profile 退出时加载：~/.bash_logout ~/.bash_history</br>
> 历史命令 !number !string !$（上一个命令的最后一个参数） !!(上一个命令) ^R(命令搜索)</br>
> 取消别名：unalias或者在命令前加\</br>
> 快捷键：^D(退出/logout) ^A(移到命令最前面) ^E(移到命令最后面) ^L() ^U(删除当前行所有命令) ^K(删除光标后面的所有) ^S(锁住命令行) ^Q(解除锁定命令行) ^Y(撤销删除) ^T 交换光标处文字次序</br>
> &（退出终端后消失） nohup(退出终端后仍然有)</br>
> 管道| ：一个命令的输出作为下一个命令的输入</br>
> 输入一行内容到文件 echo 内容 > 文件</br>
> 输入多行内容到文件 cat  >文件 << EOF</br>
> tee : 复制标准输入的内容到标准输出 参数a 表示追加</br>
> 在vim里保存没有权限的文件 :w !sudo tee %  （%在vim里是一个只读寄存器的名字，总保存着当前文件的路径）</br>
- 命令排序</br>
> ;       不具备逻辑判断 cd;eject</br>
> && ||   具备逻辑判断   ./configure && make && make install</br>
> 显示命令返回值 echo $? </br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# if条件判断参数</br>
> -f 判断文件是否存在          eg: if [ -f filename ]</br>
> -d 判断目录是否存在          eg: if [ -d dir ]</br>
> -eq 等于                     应用于：整形比较</br>
> -ne 不等于                   应用于：整形比较</br>
> -lt 小于                     应用于：整形比较</br>
> -gt 大于                     应用于：整形比较</br>
> -le 小于或等于               应用于：整形比较</br>
> -ge 大于或等于               应用于：整形比较</br>
> -a 双方都成立（and）用法：   逻辑表达式 -a 逻辑表达式</br>
> -o 单方成立 （or）  用法：   逻辑表达式 -o 逻辑表达式</br>
> -z 空字符串</br>
# if使用</br>
> if (($num1+/-/\*//$num2));then</br>
> ...</br>
> fi</br>
> if [[ $num1 -lt/-gt/.../ $num2 ]];then</br>
> ...</br>
> fi</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# for循环使用</br>
> for i in 字符变量</br>
> do</br>
> ....</br>
> done</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# tail命令的使用</br>
> tail filename 打印filename的最后十行</br>
> tail -f filename 跟踪显示filename的最后十行</br>
> tail -c n filename 显示filename的最后的n个字符</br>
> tail -n filename 显示filename的第n行至末尾的内容</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# while循环使用</br>
> while [[ ...(满足此条件执行循环) ]]</br>
> do</br>
> ...</br>
> done</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# until循环使用</br>
> until [[ ...(满足此条件退出循环) ]]</br>
> do</br>
> ...</br>
> done</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# case 选择语句使用</br>
> case $arg in</br>
> pattern1)</br>
> 语句1</br>
> ;;</br>
> pattern2)</br>
> 语句2</br>
> ;;</br>
> patternn)</br>
> 语句n</br>
> ;;</br>
> esac</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# select 选择语句使用</br>
> PS3="文本描述"  //在select语句前使用此命令则会在每次选择时显示文本描述内容</br>
> select i in "变量1" "变量2" "变量n"</br>
> do</br>
> ...</br>
> done</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# read 使用</br>
> read 变量 从标准输入里读取内容赋值给变量</br>
> read -p "文本" 变量名</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# sed 使用(在Linux下)（在Mac下需要在-i后面加一个".bak",会生成一个"原文件.bak"的备份文件）</br>
> sed 's/old/new/g' filename    //将filename里的所有old预修改为new，并在终端显示，但不会实际修改文件</br>
> sed -i 's/old/new/g' filename    //将filename里的所有old改为new</br>
> sed -i 's/^/& /g' filename       //在文件每行的最前面加一个空格</br>
> sed '文件中已经存在的字符/a 你想在前面已经存在的字符后面一行加的字符/'</br>
> sed '文件中已经存在的字符/i 你想在前面已经存在的字符前面一行加的字符/'</br>
> 在Mac下使用a\ i\ 需要以下输入方式:</br>
> sed '/文本1/a\ <CR></br>
> >文本2 filename</br>
> 在Mac下将filename里的空格转换为换行符：sed -i "" 's/ /\'$'\n''/g' filename</br>
> sed 'nd' filename 删除第n行，其余的打印到屏幕上</br>
> sed 'n,$d' filename 删除第n行到最后一行，其余打印到屏幕上</br>
> sed -i 'ns/old/new/' filename    //n表示第n行</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# find</br>
> find [目录]... [表达式] [操作]</br>
- 【表达式】：</br>
> -name 文件名 带有通配符时要加单''或双引号""</br>
> -user 用户名</br>
> -group 组名</br>
> -mtime [+-]n 查找n天前修改过的文件 “+n表示超过n天，-n表示不超过n天”</br>
> -atime [+-]n 访问</br>
> -ctime [+-]n 变更</br>
> -mmin  [+-]n 分钟</br>
> -amin  [+-]n 分钟</br>
> -cmin  [+-]n 分钟</br>
> -type [f(普通文件)/d(目录)/b(块设备文件)/c(字符设备文件)]</br>
> -size [+-]n[b(块==512字节)/c(字节)/k(1024字节)/w(字==2字节)]</br>
> -a</br>
> -o</br>
> !</br>
> \( 表达式 \)</br>
- 【操作】：</br>
> -print 显示找到的文件名</br>
> -ls 显示找到文件的详细信息</br>
> -exec command {} \; 对找到的文件执行指定命令</br>
> -ok command {} \; 对找到的文件执行指定命令,执行命令时提醒确认</br>
- 【说明】：</br>
>          未指定搜索条件时，显示目录下所有文件，包含隐藏文件。未指定目录时，默认为当前目录。未指定操作时，默认的操作是-print</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# grep 查找关键字(搜索关键字时最好用单或者双引号包含起来,有多个参数时，-e放在最后)</br>
> grep 关键字 filename/stdin  从filename或stdin里查找关键字</br>
> grep -v 关键字 除了制定的关键字之外的词</br>
> grep -E "([0-9]{1,3}\.){3}[0-9]{1,3}" //匹配类似IP地址的文本，192.168.10.10</br>
> grep -c 列出关键字所在的行数</br>
> grep -l 只显示匹配字符串的文件名</br>
> grep [OPTIONS] PATTERN [FILE...]</br>
> grep [OPTIONS] [-e PATTERN]...  [-f FILE]...  [FILE...]</br>
- OPTIONS:</br>
>    -e: 使用正则搜索</br>
>    -i: 不区分大小写</br>
>    -v: 查找不包含指定内容的行</br>
>    -w: 按单词搜索</br>
>    -c: 统计匹配到的次数</br>
>    -n: 显示行号</br>
>    -r: 逐层遍历目录查找</br>
>    -A: 显示匹配行及后面多少行, 如: -A 3, 则表示显示匹配行及后3行</br>
>    -B: 显示匹配行及前面多少行, 如: -B 3, 则表示显示匹配行及前3行</br>
>    -C: 显示匹配行前后多少行,   如: -C 3, 则表示显示批量行前后3行</br>
>    --color: 匹配到的内容高亮显示</br>
>    --include: 指定匹配的文件类型</br>
>    --exclude: 过滤不需要匹配的文件类型</br>
>    [/] 指定匹配字符的范围。如模式'[Mm]ain' 匹配 Main和main</br>
>    \< 标注词首，如模式'\<man' 匹配 manic和man，但不匹配Batman</br>
>    \> 标注词尾，如模式'man\>' 匹配 Batman和man，但不匹配manic</br>
>    ^ 标注行首，如'^The'匹配行首的The，而不匹配其他位置的The</br>
>    $ 标注行尾，如'$The'匹配行尾的The，而不匹配其他位置的The</br>
>    \|表示模式间的或关系。如'Saturday\|Sunday' 匹配Saturday或Sunday</br>
> -------------------------------------------------------------------------------------------------</br>
# awk 使用</br>
> awk -v I=$i '{if(I==$1)print $2}     //-v：允许添加变量 ，如果I等于第一列，就打印第二列</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# tar备份</br>
> 全部备份：tar -g snapshot -cvzf xx.tar.gz xx(想要备份的文件)</br>
> 增量备份：tar -g snapshot -cvzf xxx.tar.gz xx(跟上面一样的目录文件) //这里的snapshot跟上面是同一个文件，但压缩包名字要求不一样</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# ip fliter</br>
> tail -1000 /var/log/secure | grep "Failed password" | egrep -o "([0-9]{1,3}\.){3}[0-9]{1,3}" | sort -nr | uniq -c | awk '$1>=4 {print $2}'</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# ssh秘钥链接</br>
> ssh-keygen       //之后连续三次默认确定</br>
> ssh-copy-id -i /root/.ssh/id_rsa.pub +远程ip地址</br>
> ssh-copy-id -i /root/.ssh/id_rsa.pub +本地ip地址</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# wc 命令使用</br>
> -c 只统计字节数，汉字加3，字母加1</br>
> -l 只统计行数</br>
> -m 只统计字符数,不论是字母还是汉字都只加1</br>
> -w 只统计字数</br>
> 不指定参数，默认为显示行数、字数和字符数</br>
</br>
> -------------------------------------------------------------------------------------------------</br>
# gcc编译基础</br>
> 1.预处理（preprocessing）gcc -E      旧版由gcc调用cpp完成，新版作为编译的一个阶段，由gcc完成</br>
> 2.编译  （compilation）  gcc -S      gcc完成</br>
> 3.汇编  （assembly）     gcc -c      gcc调用汇编器as完成</br>
> 4.连接  （linking）      gcc         gcc调用连接器ld完成</br>
></br>
- gcc命令</br>
>         -Wall       显示所有警告信息</br>
>         -I[dirname] 将dirname目录加入到头文件搜索列表中</br>
>         -L[dirname] 将dirname目录加入到库文件搜索列表中</br>
>         -l[name]    加载名为libname.a或者libname.so的函数库。例如-lm表示连接名为libm.so的数学 函数库</br>
>         -static     使用静态库。注意：在命令行中，静态加载的库必须位于调用该库的目标文件之后</br>
- gcc代码优化（等级：0、1、2、s级），默认为0级，不进行优化</br>
>         -O 对代码基本优化（1级）</br>
>         -O2对代码进行深度优化（2级）</br>
>         -Os生成最小的可执行文件，适合嵌入式软件</br>
- gcc调试</br>
>         -g 产生能够被 GDB调速器使用的调试信息。-g可以与-O和-O2连用，以便在与最终产品尽可能相近的情况下调试代码。</br>
>         -pg在程序里加入额外 的代码，执行时产生供性能分析工具gprof使用的剖析信息，以便了解程序的耗时情况 。</br>
# man 联机手册</br>
- man 命令格式： man [option] command_name</br>
- option:</br>
>        i[p] 指定在第i节里查找。1为系统命令，2为系统调用，3为C库函数。p表示POSIX手册页，即1p为POSIX手册页，3P为POSIX库函数。</br>
>        -k   显示所有名称中含有command_name的手册页及其说明</br>
>        -f   查询全部与名称相符的手册页</br>
