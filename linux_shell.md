# 变量定义
> 变量定义等号前后不能加空格，例如："A=123" </br>

> -------------------------------------------------------------------------------------------------
# 数组定义引用
> A=( test1 test2 test3 ) </br>
> 引用: echo ${A[0/1/2/...]} </br>
> 显示所有参数 echo ${A[@]}将显示所有参数=> test1 test2 test3 </br>
> 显示参数个数 echo ${#A[@]} => 3 </br>
> 替换某个数组元素，例如退还第二个test2数组为test5: echo ${A[@]/test2/test5} </br>
> 如何删除某个数组元素，例如删除test3 => unset A[2] </br>

> -------------------------------------------------------------------------------------------------
# 计算任意精度数
> a=$(echo "scale=n;$num1/$num2"|bc) //scale=n;n是多少就保留多少位小数 </br>
> j=`bc <<< "$num1*$num2-$num3"` </br>
> b=$(echo "$num1 $num2" | awk '{printf("%n.mf\n",$1/$2)}') </br>
> awk 'BEGIN{printf"%.2f\n",'$num1'/'$num2'}' </br>

> -------------------------------------------------------------------------------------------------
# 计算整数
> c=`expr $num1 + $num2` //使用乘号\* 的时候必须使用转义符号 </br>
> let "d=$num1+$num2" </br>
> ((e=$num1+$num2)) </br>

> -------------------------------------------------------------------------------------------------
# bc 使用
> ibase指定输入的数字进制 </br>
> obase指定输出的数字进制 </br>
> scale设定小数位 </br>
> echo "obase=10;ibase=2;$num1+$num2" | bc </br>

> -------------------------------------------------------------------------------------------------
# 系统常用参数
> $# 是传给脚本的参数个数 </br>
> $n 是第n个参数 </br>
> $0 是脚本本身的名字 </br>
> $1 是传递给该shell脚本的第一个参数 </br>
> $2 是传递给该shell脚本的第二个参数 </br>
> $@ 是传给脚本的所有参数的列表 </br>
> $\* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个 </br>
> $$ 是脚本运行的当前进程ID号 </br>
> $? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误 </br>

> -------------------------------------------------------------------------------------------------
# 基本命令用法
> 输出重定向">"妙用："命令 >& 目标文件"  "命令 &> 目标文件" </br>
> 输入重定向"<"妙用："命令 < 目标文件"  "命令 < 目标文件" </br>
> bash +* ***xx.sh 和 ./xx.sh 子shell执行方式 </br>
> .(空格)xx.sh 和 source xx.sh 当前shell的执行方式* </br>********
> login shell   ==> su - username </br>
> nologin shell ==> su username </br>
> 系统级shell配置 ==> /etc/profile /etc/bashrc </br>
> 用户级shell配置 ==> 登录时加载：~/.bashrc ~/.bash_profile 退出时加载：~/.bash_logout ~/.bash_history </br>
> 历史命令 !number !string !$（上一个命令的最后一个参数） !!(上一个命令) ^R(命令搜索) </br>
> 取消别名：unalias或者在命令前加\ </br>
> 快捷键：^D(退出/logout) ^A(移到命令最前面) ^E(移到命令最后面) ^L() ^U(删除当前行所有命令) ^K(删除光标后面的所有) ^S(锁住命令行) ^Q(解除锁定命令行) ^Y(撤销删除) ^T 交换光标处文字次序 </br>
> &（退出终端后消失） nohup(退出终端后仍然有) </br>
> 管道| ：一个命令的输出作为下一个命令的输入 </br>
> 输入一行内容到文件 echo 内容 > 文件 </br>
> 输入多行内容到文件 cat  >文件 << EOF </br>
> tee : 复制标准输入的内容到标准输出 参数a 表示追加 </br>
> 在vim里保存没有权限的文件 :w !sudo tee %  （%在vim里是一个只读寄存器的名字，总保存着当前文件的路径） </br>
- 命令排序
> ;       不具备逻辑判断 cd;eject </br>
> && ||   具备逻辑判断   ./configure && make && make install </br>
> 显示命令返回值 echo $? </br>

> -------------------------------------------------------------------------------------------------
# if条件判断参数
> -f 判断文件是否存在          eg: if [ -f filename ] </br>
> -d 判断目录是否存在          eg: if [ -d dir ] </br>
> -eq 等于                     应用于：整形比较 </br>
> -ne 不等于                   应用于：整形比较 </br>
> -lt 小于                     应用于：整形比较 </br>
> -gt 大于                     应用于：整形比较 </br>
> -le 小于或等于               应用于：整形比较 </br>
> -ge 大于或等于               应用于：整形比较 </br>
> -a 双方都成立（and）用法：   逻辑表达式 -a 逻辑表达式 </br>
> -o 单方成立 （or）  用法：   逻辑表达式 -o 逻辑表达式 </br>
> -z 空字符串 </br>
# if使用
> if (($num1+/-/\*//$num2));then </br>
> ... </br>
> fi </br>
> if [[ $num1 -lt/-gt/.../ $num2 ]];then </br>
> ... </br>
> fi </br>

> -------------------------------------------------------------------------------------------------
# for循环使用
> for i in 字符变量 </br>
> do </br>
> .... </br>
> done </br>

> -------------------------------------------------------------------------------------------------
# tail命令的使用
> tail filename 打印filename的最后十行 </br>
> tail -f filename 跟踪显示filename的最后十行 </br>
> tail -c n filename 显示filename的最后的n个字符 </br>
> tail -n filename 显示filename的第n行至末尾的内容 </br>

> -------------------------------------------------------------------------------------------------
# while循环使用
> while [[ ...(满足此条件执行循环) ]] </br>
> do </br>
> ... </br>
> done </br>

> -------------------------------------------------------------------------------------------------
# until循环使用
> until [[ ...(满足此条件退出循环) ]] </br>
> do </br>
> ... </br>
> done </br>

> -------------------------------------------------------------------------------------------------
# case 选择语句使用
> case $arg in </br>
> pattern1) </br>
> 语句1 </br>
> ;; </br>
> pattern2) </br>
> 语句2 </br>
> ;; </br>
> patternn) </br>
> 语句n </br>
> ;; </br>
> esac </br>

> -------------------------------------------------------------------------------------------------
# select 选择语句使用
> PS3="文本描述"  //在select语句前使用此命令则会在每次选择时显示文本描述内容 </br>
> select i in "变量1" "变量2" "变量n" </br>
> do </br>
> ... </br>
> done </br>

> -------------------------------------------------------------------------------------------------
# read 使用
> read 变量 从标准输入里读取内容赋值给变量 </br>
> read -p "文本" 变量名 </br>

> -------------------------------------------------------------------------------------------------
# sed 使用(在Linux下)（在Mac下需要在-i后面加一个".bak",会生成一个"原文件.bak"的备份文件）
> sed 's/old/new/g' filename    //将filename里的所有old预修改为new，并在终端显示，但不会实际修改文件 </br>
> sed -i 's/old/new/g' filename    //将filename里的所有old改为new </br>
> sed -i 's/^/& /g' filename       //在文件每行的最前面加一个空格 </br>
> sed '文件中已经存在的字符/a 你想在前面已经存在的字符后面一行加的字符/' </br>
> sed '文件中已经存在的字符/i 你想在前面已经存在的字符前面一行加的字符/' </br>
> 在Mac下使用a\ i\ 需要以下输入方式: </br>
> sed '/文本1/a\ <CR> </br>
> >文本2 filename </br>
> 在Mac下将filename里的空格转换为换行符：sed -i "" 's/ /\'$'\n''/g' filename </br>
> sed 'nd' filename 删除第n行，其余的打印到屏幕上 </br>
> sed 'n,$d' filename 删除第n行到最后一行，其余打印到屏幕上 </br>
> sed -i 'ns/old/new/' filename    //n表示第n行 </br>

> -------------------------------------------------------------------------------------------------
# find
> find [目录]... [表达式] [操作] </br>
- 【表达式】：
> -name 文件名 带有通配符时要加单''或双引号"" </br>
> -user 用户名 </br>
> -group 组名 </br>
> -mtime [+-]n 查找n天前修改过的文件 “+n表示超过n天，-n表示不超过n天” </br>
> -atime [+-]n 访问 </br>
> -ctime [+-]n 变更 </br>
> -mmin  [+-]n 分钟 </br>
> -amin  [+-]n 分钟 </br>
> -cmin  [+-]n 分钟 </br>
> -type [f(普通文件)/d(目录)/b(块设备文件)/c(字符设备文件)] </br>
> -size [+-]n[b(块==512字节)/c(字节)/k(1024字节)/w(字==2字节)] </br>
> -a </br>
> -o </br>
> ! </br>
> \( 表达式 \) </br>
- 【操作】：
> -print 显示找到的文件名 </br>
> -ls 显示找到文件的详细信息 </br>
> -exec command {} \; 对找到的文件执行指定命令 </br>
> -ok command {} \; 对找到的文件执行指定命令,执行命令时提醒确认 </br>
- 【说明】：
>          未指定搜索条件时，显示目录下所有文件，包含隐藏文件。未指定目录时，默认为当前目录。未指定操作时，默认的操作是-print </br>

> -------------------------------------------------------------------------------------------------
# grep 查找关键字(搜索关键字时最好用单或者双引号包含起来,有多个参数时，-e放在最后)
> grep 关键字 filename/stdin  从filename或stdin里查找关键字 </br>
> grep -v 关键字 除了制定的关键字之外的词 </br>
> grep -E "([0-9]{1,3}\.){3}[0-9]{1,3}" //匹配类似IP地址的文本，192.168.10.10 </br>
> grep -c 列出关键字所在的行数 </br>
> grep -l 只显示匹配字符串的文件名 </br>
> grep [OPTIONS] PATTERN [FILE...] </br>
> grep [OPTIONS] [-e PATTERN]...  [-f FILE]...  [FILE...] </br>
- OPTIONS:
>    -e: 使用正则搜索 </br>
>    -i: 不区分大小写 </br>
>    -v: 查找不包含指定内容的行 </br>
>    -w: 按单词搜索 </br>
>    -c: 统计匹配到的次数 </br>
>    -n: 显示行号 </br>
>    -r: 逐层遍历目录查找 </br>
>    -A: 显示匹配行及后面多少行, 如: -A 3, 则表示显示匹配行及后3行 </br>
>    -B: 显示匹配行及前面多少行, 如: -B 3, 则表示显示匹配行及前3行 </br>
>    -C: 显示匹配行前后多少行,   如: -C 3, 则表示显示批量行前后3行 </br>
>    --color: 匹配到的内容高亮显示 </br>
>    --include: 指定匹配的文件类型 </br>
>    --exclude: 过滤不需要匹配的文件类型 </br>
>    [/] 指定匹配字符的范围。如模式'[Mm]ain' 匹配 Main和main </br>
>    \< 标注词首，如模式'\<man' 匹配 manic和man，但不匹配Batman
>    \> 标注词尾，如模式'man\>' 匹配 Batman和man，但不匹配manic </br>
>    ^ 标注行首，如'^The'匹配行首的The，而不匹配其他位置的The </br>
>    $ 标注行尾，如'$The'匹配行尾的The，而不匹配其他位置的The </br>
>    \|表示模式间的或关系。如'Saturday\|Sunday' 匹配Saturday或Sunday </br>
> -------------------------------------------------------------------------------------------------
# awk 使用
> awk -v I=$i '{if(I==$1)print $2}     //-v：允许添加变量 ，如果I等于第一列，就打印第二列 </br>

> -------------------------------------------------------------------------------------------------
# tar备份
> 全部备份：tar -g snapshot -cvzf xx.tar.gz xx(想要备份的文件) </br>
> 增量备份：tar -g snapshot -cvzf xxx.tar.gz xx(跟上面一样的目录文件) //这里的snapshot跟上面是同一个文件，但压缩包名字要求不一样 </br>

> -------------------------------------------------------------------------------------------------
# ip fliter
> tail -1000 /var/log/secure | grep "Failed password" | egrep -o "([0-9]{1,3}\.){3}[0-9]{1,3}" | sort -nr | uniq -c | awk '$1>=4 {print $2}' </br>

> -------------------------------------------------------------------------------------------------
# ssh秘钥链接
> ssh-keygen       //之后连续三次默认确定 </br>
> ssh-copy-id -i /root/.ssh/id_rsa.pub +远程ip地址 </br>
> ssh-copy-id -i /root/.ssh/id_rsa.pub +本地ip地址 </br>

> -------------------------------------------------------------------------------------------------
# wc 命令使用
> -c 只统计字节数，汉字加3，字母加1 </br>
> -l 只统计行数 </br>
> -m 只统计字符数,不论是字母还是汉字都只加1 </br>
> -w 只统计字数 </br>
> 不指定参数，默认为显示行数、字数和字符数 </br>

> -------------------------------------------------------------------------------------------------
# gcc编译基础
> 1.预处理（preprocessing）gcc -E      旧版由gcc调用cpp完成，新版作为编译的一个阶段，由gcc完成
> 2.编译  （compilation）  gcc -S      gcc完成
> 3.汇编  （assembly）     gcc -c      gcc调用汇编器as完成
> 4.连接  （linking）      gcc         gcc调用连接器ld完成
>
- gcc命令
>         -Wall       显示所有警告信息 </br>
>         -I[dirname] 将dirname目录加入到头文件搜索列表中 </br>
>         -L[dirname] 将dirname目录加入到库文件搜索列表中
>         -l[name]    加载名为libname.a或者libname.so的函数库。例如-lm表示连接名为libm.so的数学 函数库 </br>
>         -static     使用静态库。注意：在命令行中，静态加载的库必须位于调用该库的目标文件之后 </br>
- gcc代码优化（等级：0、1、2、s级），默认为0级，不进行优化
>         -O 对代码基本优化（1级） </br>
>         -O2对代码进行深度优化（2级） </br>
>         -Os生成最小的可执行文件，适合嵌入式软件 </br>
- gcc调试
>         -g 产生能够被 GDB调速器使用的调试信息。-g可以与-O和-O2连用，以便在与最终产品尽可能相近的情况下调试代码。 </br>
>         -pg在程序里加入额外 的代码，执行时产生供性能分析工具gprof使用的剖析信息，以便了解程序的耗时情况 。 </br>
# man 联机手册
- man 命令格式： man [option] command_name
- option:
>        i[p] 指定在第i节里查找。1为系统命令，2为系统调用，3为C库函数。p表示POSIX手册页，即1p为POSIX手册页，3P为POSIX库函数。 </br>
>        -k   显示所有名称中含有command_name的手册页及其说明 </br>
>        -f   查询全部与名称相符的手册页 </br>
